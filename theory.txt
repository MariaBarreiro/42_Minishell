Videos:
- https://www.youtube.com/watch?v=xCySbqj9BKI&list=PL2POs8ZJ4I2JJK3lICRW0b-L2y9mLiDmU

Books:

**Unix and Linux System administration handbook**


-Pipes and redirection (Page 33)-
    -> Every shell has at least three communication channels available: STDIN, STDOUT and STDERR (standard input(0), standard output(1) and standard error(2));
    -> Most commands accept their input from STDIN and write their output to STDOUT.
    -> Shell interprets symbols: 
         --> '<' connects the command's STDIN to the contents of an existing file. (Take the input for a program from the following file instead of from the terminal).
        --> '>' and '>>' redirects STDOUT.
        --> '>' replaces the file's existing contents. (put the output in the following file rather than the terminal).
        --> '>>' appends to the file's existing contents. (add the output to the end of the following file instead of the terminal).
    -> To connect the STDOUT of one command to the STDIN of another, use the | symbol.     --> ps -ef | grep httpd (runs ps command to generate a list of processes and pipes it through the grep command to slsect lines that contain the word httpd. The output of grep is not redirected, so the matching lines come to the terminal window).
    -> To execute a second command only if its precursor completes successfully, you can separate the commands with an && symbol (logical AND).
    -> The || symbol executes the following command only if the preceding command fails (aka produces a nonzero exit status).


-Variables and quoting-
    -> Variable names are unmarked in assignments but prefixed with a dollar sign when their vlaues are referenced: 
        --> $ etcdir='/etc'
        --> $ echo $etcdir
        --> /etc
        --> Referencing a variable can be done like: $etcdir (the one on the example above) or ${etcdir}. The {} are not normally required but are useful when you want to expand variables inside double-quoted strings:
            ---> $ echo "Saved ${rev}th version of mdadm.conf."
            ---> Saved 8th version of mdadm.conf.
    -> ALL CAPS normally suggest environment variables or variables read from global configuration files.
        --> Environment variables are dynamic, named values that are set outside of a program and influence how processes run on a computer.
        --> They are automatically imported into bash's variable namespace, so they can be set and read with the standard syntax.
    -> lowercase separated with _ suggest local variables.
    -> The shell treats strings enclsed in single and double quotes similarly, except that double quoted strings are subject to globbing (the expansion of filename-matching metacharacters such as * and ?) and variable expansion:
        --> $ mylang="Pennsylvania Dutch"
        --> $ echo "I speak ${mylang}."
        --> I speak Pennsylvania Dutch.
        --> $ echo 'I speak ${mylang}.'
        --> I speak ${mylang}.
    -> Back quotes ( `` ) are treated similarly to double quotes, but they have an additional effect of eecuting the contents of the string as a shell command and replacing the string with the command's output:
        --> $ echo "There are `wc -l < /etc/passwd` lines in the passwd file."
        --> There are 28 lines in the passwd file.


-Common filter commands-
    -> Any well-behaved command that reads STDIN and writes STDOUT can be used as a filter (component of a pipeline) to process data.






**The Unix programming environment**

-Pipes-
    -> Pipe is a way to connect the output of one program to the input of another program without any temporary file. 
    -> A pipeline is a connection of two or more programs through pipes.
    -> The programs in a pipeline run at the same time!
    -> Most commands follow a commons design:
        --> command optional-arguments optional-filenames.
        --> If no filenames are given, the command reads to the standard input (the terminal).

-Processes-
    -> Program VS processes:
        --> An instance of running a program is called a process.
        --> For example, wc (word count) is a program that each time that it is run creates a new process. If several instances of the same program are running at the same time, each is a separate process with a different process-id.
    -> PID is a process-ID.
    -> TTY is the terminal associated with the process.
    -> Processes have an hierarchical structure:
        --> Each process has a parent, and may well have children.
        --> Your shell was created by a process associated with whatever terminal line connects you to the system. As I run commands, those processes are the direct children of your shell. If you run a program from within one of those, that creates its own child process, which is thus a grandchild of the shell.

-Tailoring the environment-
    -> The file called .profile in your login directory, are all the commands the shell will execute when you log in, before printing the first prompt.
    -> Some of the properties of the shell are actually controlled by the so-called shell variables, with values that you can access and set yourself.
        --> The prompt string, ($), is stored in a variable called PS1.
    -> The shell also treats the variables HOME and MAIL specially.
        --> HOME is the name of your home directory, it is normally set properly whitout having to be in .profile.
        --> MAIL names the standard file where your mail is kept.
    -> PATH is also a very useful shell variable.
        --> PATH controls where the shell looks for commands.

//The file system//
-What's in a file?-
    -> There are four typical files, all related to the editor:
        --> $ file /bin /bin/ed /usr/stc/cmd/ed.c /usr/man/man1/ed.1
            ---> The directory in which it resides (/bin).
            ---> The "binary" or runnable program itself (/bin/ed).
            ---> The "source" or C statements that define the program (/usr/src/cmd/ed.c).
            ---> The manual page (/usr/man/man1/ed.1).

//Using the shell//
-Metacharacters-
    -> '*': tells the shell to search the directory for filenames in which any string of characters occurs in the position of the *.
    -> '>'.
    -> '>>' program >> file: appends standard output to file.
    -> '<'.
    -> '|' p1 | p2: connects standard output of p1 to standard input of p2. 
    -> '<<str' here document: standard input follows, up to next str on a line by itself.
    -> '?': match any single character in filenames.
    -> '[ccc]': match any single character from ccc in filenames.
    -> ';' p1 ; p2: command terminator. Does p1 then p2.
    -> '&': Like ; but doesn't wait for p1 to finish.
    -> '`...`': run command(s) in ...; output replaces `...`.
    -> '(...)': run command(s) in ... in a sub-shell.
    -> '$1, $2 ... $9': replaced by arguments to shell file.
    -> '$var': value of shell variable var.
    -> '\' \c: take character c literally.
    -> '´...´': take ... literally.
    -> '"..."': take ... literally after $, `...`and \ interpreted.
    -> '#': comment.
    -> 'var=value': assign to variable var.
    -> 'p1 && p2': run p1, if successful run p2.
    -> 'p1 || p2': run p1, if unsuccessful run p2.

-Echo-
    -> Ends with newline! Can be supressed with the '-n'!
    -> 














